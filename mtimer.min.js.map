{"version":3,"sources":["sourceMap"],"names":["window","Timer","constructor","p","P","B","y","Date","U","arguments","k","eval","clearTimer"],"mappings":"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","sourcesContent":["'use strict'\n/** Timer manager.\n *\n * Override global JS functions setTimeout() & setInterval()\n * to allow management task on them\n *\n * @author Damien Cuvillier <damien@gotan.io>\n * @License MIT\n *\n * Feel free to thanks: https://tinyurl.com/2kh78j52\n * */\n\n// Overriding originals\nwindow.originalSetTimeout = window.setTimeout;\nwindow.originalSetInterval = window.setInterval;\nwindow.originalClearTimeout = window.clearTimeout;\nwindow.originalClearInterval = window.clearInterval;\n\n\n/** Global repository of all active timers (interval & timeouts)\n * @type [\n * {\n *     id: number,\n *     type: 'interval'|'timeout',\n *     functionName: string,\n *     delay: number,\n *     startTime: Date\n * },\n * ]\n *\n */\nwindow.timers = [];\n\n/** Generic Timer (interval ou timeout representation */\nclass Timer{\n    constructor (id, type, functionName, delay) {\n        this.id = id;\n        this.type = type;\n        this.functionName = functionName;\n        this.delay = delay;\n        this.startTime = new Date();\n    }\n}\n\n/** The setTimeout() method of the WindowOrWorkerGlobalScope mixin\n *  sets a timer which executes a function or specified piece of code once the timer expires.\n *\n * Override setTimeout basic function to allow timers management.\n *\n * @param callbackFunction Function to callback after delay\n * @param delay Delay in ms\n * @param args As many arguments as your need\n * @returns number timeoutId of created timeout\n */\nwindow.setTimeout = function(callbackFunction, delay, ...args) {\n    let cmd = 'window.originalSetTimeout(callbackFunction,delay'\n    for (let i = 0; i < arguments.length ; i ++) {\n        cmd += \", args[\" + i + \"]\";\n    }\n    cmd += ');';\n    /* We use deprecated eval syntax to deal with ...arguments syntax\n     * Otherwise, it sends an args[] array.\n     */\n    const id = eval (cmd);\n\n    window.originalSetTimeout(clearTimer, delay, id);\n    window.timers.push(new Timer(id, 'timeout', callbackFunction.name, delay));\n    return id;\n};\n/** The setInterval() method, offered on the Window and Worker interfaces\n * repeatedly calls a function or executes a code snippet, with a fixed time delay between each call.\n * It returns an interval ID which uniquely identifies the interval, so you can remove it later by calling clearInterval().\n * This method is defined by the WindowOrWorkerGlobalScope mixin.\n *\n * @param callbackFunction\n * @param delay Delay in ms\n * @param args As many arguments as your need\n * @returns number intervalId of created interval\n */\nwindow.setInterval = function(callbackFunction, delay, ...args) {\n    let cmd = 'window.originalSetInterval(callbackFunction,delay'\n    for (let i = 0; i < args.length ; i ++) {\n        cmd += \", args[\" + i + \"]\";\n    }\n    cmd += ');';\n    /* We use deprecated eval syntax to deal with ...arguments syntax\n    * Otherwise, it sends an args[] array.\n    */\n    const id = eval(cmd);\n    window.timers.push(new Timer(id, 'interval', callbackFunction.name, delay));\n    return id;\n};\n\n/** Clear specific timeout from its ID\n * (created by setTimeout function)\n * @param timeoutId\n */\nwindow.clearTimeout = function(timeoutId) {\n    clearTimer(timeoutId);\n    window.originalClearTimeout(timeoutId);\n};\n/** Clear specific interval from its intervalId\n * (created by setInterval function)\n * @param intervalId\n */\nwindow.clearInterval = function(intervalId) {\n    clearTimer(intervalId);\n    window.originalClearInterval(intervalId);\n};\n\n/** Clear a timer from its id\n * @param timerId (either created by setInterval ou setTimeout functions)\n */\nwindow.clearTimer = function(timerId)  {\n    let searchTimer = window.timers.filter(t => t.id === timerId);\n\n    if (searchTimer.length > 0) {\n        if (searchTimer[0].type === 'timeout') {\n            window.originalClearTimeout(searchTimer[0].id);\n        } else if (searchTimer[0].type === 'interval') {\n            window.originalClearInterval(searchTimer[0].id);\n        }\n        const idx = window.timers.indexOf(searchTimer[0]);\n        window.timers.splice(idx,1);\n    }\n};\n\n/** Reset all known active timers (timeouts and intervals)\n *\n * @param type (optional): interval|timeout\n *  you can specify either timeout or interval\n *  default: both\n * @returns number how many timers have been erased\n */\nwindow.clearTimers = function (type) {\n    let timers;\n    if (type == null) {\n        timers = window.timers;\n    } else {\n        timers = window.timers.filters(t => t.type === type);\n    }\n    const count = timers.length;\n    timers.forEach(t => window.clearTimer(t.id));\n    return count;\n};"]}